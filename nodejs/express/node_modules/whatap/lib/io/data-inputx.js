/**
 * Copyright 2016 the WHATAP project authors. All rights reserved.
 * Use of this source code is governed by a license that
 * can be found in the LICENSE file.
 */

var constants       = require('../env/constants'),
    ValueEnum       = require('../value/valueenum'),
    CounterPack     = require('../pack/counter-pack'),
    ActiveStackPack = require('../pack/activestack-pack'),
    TextPack        = require('../pack/text-pack').TextPack,
    StatHttpcPack   = require('../pack/stathttpc-pack').StatHttpcPack,
    StatErrorPack   = require('../pack/staterror-pack').StatErrorPack,
    ParamPack       = require('../pack/param-pack').ParamPack,
    EventPack       = require('../pack/event-pack').Instance,
    PackEnum        = require('../pack/packenum'),
    Logger          = require('../logger'),
    Long            = require('long');

function DataInputX(inputBuf) {
    this.buf = new Buffer(inputBuf.length);
    inputBuf.copy(this.buf);
    this.offset = 0;
}

DataInputX.prototype.size = function() {
    return this.buf.length;
};

DataInputX.prototype.available = function() {
    return (this.size() - this.offset) > 0;
};

DataInputX.prototype.readDecimal = function() {
    var len = this.readByte();
    var value = 0;
    if (len == 0) {
        value = 0;
    } else if (len == 1) {
        value = this.readInt8();
    } else if (len == 2) {
        value = this.readUInt16BE();
    } else if (len == 3) {
        value = this.readInt24BE();
    } else if (len == 4) {
        value = this.readInt32BE();
    } else if (len == 5) {
        value = this.readInt40BE();
    } else if (len == 8) {
        value = this.readLong();
    }
    return value;
};

DataInputX.prototype.readBlob = function() {
    var baseLength = this.readUInt8();
    var blobBuf;
    if (baseLength == 255) {
        var len = this.readInt16BE();
        blobBuf = this.readSlice(len);
    } else if (baseLength == 254) {
        var len = this.readInt32BE();
        blobBuf = this.readSlice(len);
    } else if (baseLength == 0) {
        blobBuf = new Buffer(0);
    } else {
        blobBuf = this.readSlice(baseLength);
    }
    return blobBuf;
};

DataInputX.prototype.read = function(len) {
    return this.readSlice(len);
};

DataInputX.prototype.readSlice = function(len) {
    var slice = this.buf.slice(this.offset, this.offset + len);
    this.offset += len;
    return slice;
};

DataInputX.prototype.readText = function() {
    var blobBuf = this.readBlob();
    return blobBuf.toString("utf8", 0, blobBuf.length);
};

DataInputX.prototype.readByte = function() {
    var value = this.buf[this.offset];
    this.offset += 1;
    return value;
};

DataInputX.prototype.readIntBytes = function(value) {
    var len = this.readInt32BE();

    if(len < 0 || len > value){
        Logger.printError('WHATAP-210', "read byte is overflowed max:" + max + " len:" + len, new Error());
    }
    return this.read(len);
};

DataInputX.prototype.readShortBytes = function() {
    var len = this.readUInt16BE();
    return this.read(len);
};

DataInputX.prototype.readInt8 = function() {
    // var value = this.buf[this.offset];
    var value = this.buf.readInt8(this.offset);
    this.offset += 1;
    return value;
};

DataInputX.prototype.readUInt8 = function() {
    var value = this.buf[this.offset];
    this.offset += 1;
    return value;
};

DataInputX.prototype.readShort = function() {
    var value = this.buf.readInt16BE(this.offset);
    this.offset += 2;
    return value;
};

DataInputX.prototype.readInt16BE = function() {
    var value = this.buf.readInt16BE(this.offset);
    this.offset += 2;
    return value;
};

DataInputX.prototype.readUInt16BE = function() {
    var value = this.buf.readUInt16BE(this.offset);
    this.offset += 2;
    return value;
};

DataInputX.prototype.readInt24BE = function() {
    var ch1 = this.buf[this.offset];
    var ch2 = this.buf[this.offset + 1];
    var ch3 = this.buf[this.offset + 2];
    this.offset += 3;
    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8)) >> 8;
};

DataInputX.prototype.readInt = function() {
    var value = this.buf.readInt32BE(this.offset);
    this.offset += 4;
    return value;
};

DataInputX.prototype.readInt32BE = function() {
    var value = this.buf.readInt32BE(this.offset);
    this.offset += 4;
    return value;
};

DataInputX.prototype.readUInt32BE = function() {
    var value = this.buf.readUInt32BE(this.offset);
    this.offset += 4;
    return value;
};

DataInputX.prototype.readInt40BE = function(){
    var value = this.buf.readIntBE(this.offset, 5);
    this.offset += 5;
    return value;
};

DataInputX.prototype.readFloat = function() {
    var value = this.buf.readFloatBE(this.offset);
    this.offset += 4;
    return value;
};

DataInputX.prototype.readValue = function() {
    var type = this.readByte();
    return ValueEnum.create(type).read(this);
};

DataInputX.prototype.readLong = function(){
    var low = this.readInt32BE();
    var high = this.readInt32BE();
    var l = Long.fromBits(high, low);
    return l;
};

DataInputX.prototype.readPack = function() {
    var type = this.readInt16BE();

    if(type == PackEnum.COUNTER) {
        return new CounterPack().read(this);
    } else if(type == PackEnum.ACTIVESTACK) {
        return new ActiveStackPack().read(this);
    } else if(type == PackEnum.TEXT) {
        return new TextPack().read(this);
    } else if( type == PackEnum.STAT_HTTPC ) {
        return new StatHttpcPack().read(this);
    } else if( type == PackEnum.STAT_ERROR ) {
        return new StatErrorPack().read(this);
    } else if( type == PackEnum.EVENT ) {
        return new EventPack().read(this);
    } else if( type == PackEnum.PARAMETER ){
        return new ParamPack().read(this);
    }
    return null;
};

DataInputX.prototype.readStep = function() {
    // TODO : empty function need to be implemented
};

DataInputX.prototype.readBoolean = function() {
    var isTrue = this.readByte();
    if (isTrue == 1) {
        return true;
    } else {
        return false;
    }
};

DataInputX.prototype.readFloatArray = function() {
    var length = this.readShort(),
        data = new Array(length);
    for(var i=0; i<length; i++) {
        data[i] = this.readFloat();
    }
    return data;
};

DataInputX.prototype.readIntArray = function() {
    var length = this.readShort(),
        data = new Array(length);
    for (var i = 0; i < length; i++) {
        data[i] = this.readInt();
    }
    return data;
};

DataInputX.prototype.readLongArray = function() {
    var length = this.readShort(),
        data = new Array(length);

    for (var i = 0; i < length; i++) {
        data[i] = this.readLong();
    }
    return data;
};

DataInputX.toBoolean = function(buf, pos) {
    return buf[pos] != 0;
};

DataInputX.toShort = function(buf, pos) {
    var ch1 = buf[pos] & 0xff;
    var ch2 = buf[pos + 1] & 0xff;
    return ((ch1 << 8) + (ch2 << 0));
};

DataInputX.toInt3 = function(buf, pos) {
    var ch1 = buf[pos] & 0xff;
    var ch2 = buf[pos + 1] & 0xff;
    var ch3 = buf[pos + 2] & 0xff;
    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8)) >> 8;
};

DataInputX.toInt = function(buf, pos) {
    var ch1 = buf[pos] & 0xff;
    var ch2 = buf[pos + 1] & 0xff;
    var ch3 = buf[pos + 2] & 0xff;
    var ch4 = buf[pos + 3] & 0xff;
    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
};

DataInputX.toLong5 = function(buf, pos) {
    return (buf[pos] << 32) +
        ((buf[pos + 1] & 0xff) << 24)+
        ((buf[pos + 2] & 0xff) << 16)+
        ((buf[pos + 3] & 0xff) << 8) +
        ((buf[pos + 4] & 0xff) << 0);
};

DataInputX.get = function(buf, pos, length) {
    var out = new Buffer(length);
    buf.copy(out, pos, length);
    return out;
};

module.exports = DataInputX;