/**
 * Copyright 2016 the WHATAP project authors. All rights reserved.
 * Use of this source code is governed by a license that
 * can be found in the LICENSE file.
 */

var DataPackSender  = require('./datapack-sender'),
    StatTranX       = require('../stat/stat-tranx'),
    StatRemoteIp    = require('../stat/stat-remoteip'),
    StatUserAgent   = require('../stat/stat-useragent'),
    conf            = require('../conf/configure'),
    Logger          = require('../logger'),
    Long            = require('long');

var DataProfileAgent = {
    last_reject : 0,
    sendProfile : function (ctx, profile, rejected) {
        try {
            StatRemoteIp.incRemoteIp(ctx.remoteIp);
            StatUserAgent.incUserAgent(ctx.userAgent);

            var transaction = profile.service;
            var stat = StatTranX.getService(transaction.service);

            if(stat != null) {
                stat.count++;
                if(transaction.error != 0) {
                    stat.error++;
                }
                if(transaction.elapsed < 0) {
                    transaction.elapsed = 0;
                }

                stat.actived += ctx.profileActive;
                stat.time_sum = stat.time_sum.add(transaction.elapsed);
                stat.time_std = stat.time_std.add(Long.fromNumber(transaction.elapsed).mul(transaction.elapsed));
                if (transaction.elapsed < stat.time_min) {
                    stat.time_min = transaction.elapsed;
                }
                if (transaction.elapsed > stat.time_max) {
                    stat.time_max = transaction.elapsed;
                }
                stat.sql_count += transaction.sqlCount;
                stat.sql_select += ctx.sql_select;
                stat.sql_insert += ctx.sql_insert;
                stat.sql_delete += ctx.sql_delete;
                stat.sql_update += ctx.sql_update;
                stat.sql_others += ctx.sql_others;
                stat.sql_time = stat.sql_time.add(transaction.sqlTime);
                stat.sql_fetch += ctx.rs_count;
                stat.sql_fetch_time = stat.sql_fetch_time.add(ctx.rs_time);
                stat.sql_commit_count += ctx.jdbc_commit;
                stat.sql_update_record += ctx.jdbc_update_record;
                stat.httpc_count += transaction.httpcCount;
                stat.httpc_time = stat.httpc_time.add(transaction.httpcTime);
                stat.malloc_sum = stat.malloc_sum.add(transaction.malloc);
                stat.cpu_sum = stat.cpu_sum.add(transaction.cpuTime);

                switch (ctx.status / 100) {
                    case 2:
                        stat.status200++;
                        break;
                    case 3:
                        stat.status300++;
                        break;
                    case 4:
                        stat.status400++;
                        break;
                    case 5:
                        stat.status500++;
                        break;
                }

                if (rejected) {
                    var now = Date.now();
                    if (now < this.last_reject + 1000) {
                        return;
                    }
                    this.last_reject = now;
                } else if (stat.profiled == true    // 이전(5분구간 내)에 프로파일이 수집된점이 있음
                    && ctx.profileActive == 0       // 액티브 스택을 추적한적이 없음
                    && transaction.elapsed < (conf.profile_basetime || 1000)
                    && transaction.error == 0) {
                    return;
                }
                stat.profiled = true;
            }

            var steps = ctx.profile.getSteps();
            profile.setProfile(steps);
            DataPackSender.sendProfilePack(profile);
            
        } catch(e) {
            Logger.printError('WHATAP-199', 'dataprofile-agent error', e);
        }
    }
};

module.exports = DataProfileAgent;