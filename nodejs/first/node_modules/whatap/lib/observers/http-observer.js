/**
 * Copyright 2016 the WHATAP project authors. All rights reserved.
 * Use of this source code is governed by a license that
 * can be found in the LICENSE file.
 */

var TraceContextManager = require('../trace/trace-context-manager'),
    BuildPos            = require('../trace/build-pos'),
    DataTextAgent       = require('../data/datatext-agent'),
    DataProfileAgent    = require('../data/dataprofile-agent'),
    HttpStepX           = require('../step/http-stepx'),
    WasService          = require('../service/was-service'),
    StatError           = require('../stat/stat-error'),
    StatHttpc           = require('../stat/stat-httpc'),
    ProfilePack         = require('../pack/profile-pack'),
    DataInputX          = require('../io/data-inputx'),
    SecurityMaster      = require('../net/security-master'),
    MeterService        = require('../counter/meter/meter-service').MeterService,
    MeterUsers          = require('../counter/meter/meter-users'),
    MeterHttpC          = require('../counter/meter/meter-httpc'),
    conf                = require('../conf/configure'),
    hashUtil            = require('../util/hashutil'),
    UserIdUtil          = require('../util/userid-util'),
    DateUtil            = require('../util/dateutil'),
    IPUtil              = require('../util/iputil'),
    ResourceProfile     = require('../util/resourceprofile'),
    TextTypes           = require('../lang/text-types'),
    PluginLoaderManager = require('../plugin/plugin-loadermanager'),
    Long                = require('long');

var configIpHeaderKey = undefined;

conf.on('trace_http_client_ip_header_key', function(newProperty){
    configIpHeaderKey = newProperty;
});

var HttpObserver = function(agent){
    this.agent = agent;
    this.packages = ['http'];

    this.initCtx = function(req, res){
        var ctx = TraceContextManager.start();
        req.__ctx_id__ = ctx._id;

        ctx.service_name = req.url;
        ctx.service_hash = hashUtil.hashFromString(ctx.service_name);
        ctx.isStaticContents = !(req.url.match(/.css|.js/) == null);
        ctx.referer = hashUtil.hashFromString(req.headers['referer']);
        ctx.userAgentString = req.headers['user-agent'];
        if (ctx.userAgentString !== null && typeof ctx.userAgentString !== 'undefined') {
            ctx.userAgent = hashUtil.hashFromString(ctx.userAgentString);
            DataTextAgent.USERAGENT.add(ctx.userAgent, ctx.userAgentString);
        }

        ctx.start_malloc = ResourceProfile.getUsedHeapSize();
        ctx.start_cpu = ResourceProfile.getCPUTime();
        ctx.http_method = req.method;
        ctx.http_query = JSON.stringify(req.query); //pram은?
        ctx.http_content_type = req.headers['content_type'];

        try {
            var remote_addr = req.headers[configIpHeaderKey] || req.connection.remoteAddress || 0;
            if(remote_addr === '::1') {
                remote_addr = '127.0.0.1';
            } else {
                remote_addr = IPUtil.process(remote_addr).toString();
            }
            ctx.remoteIp = DataInputX.toInt(IPUtil.toBytes(remote_addr), 0);
            switch (conf.trace_user_using_type || 3) {
                case 1:
                    ctx.userid = ctx.remoteIp;
                    MeterUsers.add(ctx.userid);
                    break;
                case 2:
                    // ctx.userid = UserIdUtil.getUseridCustom(request, response, "JSESSION");
                    MeterUsers.add(ctx.userid);
                    break;
                case 3:
                    ctx.userid = UserIdUtil.getUserId(req, res, 0);
                    MeterUsers.add(ctx.userid);
                    break;
            }
        } catch (e) {
            // ignore
        }

        return ctx;
    }
};

HttpObserver.prototype.__createTransactionObserver = function(callback, isHttps) {
    var self = this;
    var aop = this.agent.aop;

    return function (req, res) {
        var ctx = self.initCtx(req, res);
        PluginLoaderManager.do('httpservicestart', ctx, req, res);

        res.socket.on('timeout', function () {
            StatError.error = new Error().stack.split('\n');
            var msgObj = { 'class': 'Timeout', 'msg': 'Timeout' };
            ctx.error = StatError.addError({} /*Throwable*/, msgObj, ctx.service_hash, ctx.profile, 0, 0);
            self.__endTransaction(null, ctx, req, res);
        });

        aop.after(res, 'end', function(obj, args) {
            if(ctx == null) return;

            PluginLoaderManager.module_holder['httpserviceend']._process(ctx, req, res);

            ctx.isStaticContents = !(req.url.match(/.css|.js/) == null);
            ctx.service_name = (req.baseUrl == null) ? '': req.baseUrl;
            ctx.service_name += req.route ? req.route.path : req.url;
            ctx.service_hash = hashUtil.hashFromString(ctx.service_name);

            ctx.http_method = req.method;
            ctx.http_query = JSON.stringify(req.query);
            ctx.http_content_type = req.headers['content_type'];

            ctx.status = Math.floor(obj.statusCode / 100);
            if (ctx.status >= 4 && ctx.error.isZero()) {
                StatError.error = new Error().stack.split('\n');
                var msgObj = { 'class': obj.statusMessage, 'msg': obj.statusMessage };
                ctx.error = StatError.addError({} /*Throwable*/, msgObj, ctx.service_hash, ctx.profile, 0, 0);
            }
            self.__endTransaction(null, ctx, req, res);
        });

        try {
            return callback.apply(this, arguments);
        } catch (e) {
            self.__endTransaction(e, ctx, req, res);
            throw e;
        }
    };
};

HttpObserver.prototype.__endTransaction = function(error, ctx, req, res) {
    if(error) {
        TraceContextManager.end(ctx != null ? ctx._id : null);
        ctx = null;
        return;
    }
    
    if(ctx == null || TraceContextManager.isExist(ctx._id) == false) {
        return;
    }

    var profile = new ProfilePack();
    var service = new WasService();
    profile.time = Long.fromValue(ctx.start_time);
    service.endTime = DateUtil.currentTime();
    service.elapsed = ctx.getElapsedTime();
    service.service = ctx.service_hash;
    service.cpuTime = ResourceProfile.getCPUTime().sub(ctx.start_cpu).toNumber();
    service.malloc = ResourceProfile.getUsedHeapSize().sub(ctx.start_malloc).toNumber();
    if(service.malloc < 0) {
        service.malloc = Long.fromNumber(0);
    }
    service.seq = ctx.profile_seq;
    service.sqlCount = ctx.sql_count;
    service.sqlTime = ctx.sql_time;
    service.sqlFetchCount = ctx.rs_count;
    service.sqlFetchTime = parseInt(ctx.rs_time);
    service.ipaddr = ctx.remoteIp;
    service.userid = ctx.userid;

    if (!ctx.error.isZero() /*long*/) {
        service.error = ctx.error;
    } else if (ctx.userTransaction > 0) { //TraceSQL에서 값이 증감됨.
        StatError.error = new Error().stack.split('\n');
        var msgObj = { 'class': 'Message!?', 'msg': 'Message!?' };
        ctx.service = StatError.addError({} /*Throwable*/, msgObj,
            ctx.service_hash, ctx.profile, 0, 0);
    }
    service.userAgent = ctx.userAgent;
    service.referer = ctx.referer;

    service.httpcCount = ctx.httpc_count;
    service.httpcTime = ctx.httpc_time;
    service.status = ctx.status;

    MeterService.add(service.service, service.elapsed, service.malloc,
        !service.error.isZero(), 0, service.sqlCount > 0);
    profile.oid = SecurityMaster.OID;
    profile.service = service;

    DataTextAgent.SERVICE.add(ctx.service_hash, ctx.service_name);
    DataProfileAgent.sendProfile(ctx, profile, false);

    TraceContextManager.end(ctx._id);
    ctx = null;
};

HttpObserver.prototype.inject = function( mod, moduleName ) {
    var self = this;
    var aop = self.agent.aop;

    if(mod.__whatap_observe__) { return; }
    mod.__whatap_observe__ = true;

    if(!conf.getProperty('trx_profile_enabled', true)) return;
    aop.before(mod.Server.prototype, ['on', 'addListener'], function (obj, args) {
        if(args[0] !== 'request') return;
        args[args.length-1] = self.__createTransactionObserver(args[args.length-1], moduleName === 'https');
    });

    if(!conf.getProperty('trx_profile_httpc_enabled', true)) return;
    aop.both(mod, 'request',
        function (obj, args, lctx) {
            var ctx = lctx.context;
            if (ctx == null) { return; }
            if(args[0].host == null) {
                return;
            }

            var dataConsumption = false;
            ctx.stack.push('Httpc request');

            if(args.length > 0) {
                var info = args[0];
                ctx.httpc_url = info.path || '/';
                ctx.httpc_host = info.host || '';
                ctx.httpc_port = info.port || -1;
            }
            if (ctx.httpc_port === undefined || ctx.httpc_port < 0) ctx.httpc_port = 80;

            var step = new HttpStepX();
            step.start_time = ctx.getElapsedTime();
            step.url = hashUtil.hashFromString(ctx.httpc_url);
            DataTextAgent.HTTPC_URL.add(step.url, ctx.httpc_url);
            step.host = hashUtil.hashFromString(ctx.httpc_host);
            DataTextAgent.HTTPC_HOST.add(step.host, ctx.httpc_host);
            step.port = ctx.httpc_port;

            var error_stack = new Error().stack.split('\n');
            StatError.error = error_stack;
            BuildPos.error = error_stack;
            BuildPos.profileHttpcPos(step, ctx.httpc_url);
            ctx.active_httpc_hash = step.url;
            lctx.step = step;

            aop.functionHook(args, -1,  function(obj, args) {
                var res = args[0];
                aop.before(res, ['on', 'addListener'], function(obj, args) {
                    // workaround for end event
                    if(!dataConsumption && args[0] === 'data') {
                        dataConsumption = true;
                    }
                });
                aop.before(res, 'pipe', function() {
                    dataConsumption = true;
                });
                aop.before(res, 'resume', function() {
                    dataConsumption = true;
                });
                
                if (dataConsumption) return;
                TraceContextManager.resume(ctx._id);
                endHttpc(ctx, step);

            }, null);
        },
        function (obj, args, ret, lctx) {
            var ctx = lctx.context;
            if (ctx == null) { return; }
            if(args[0].host == null) {
                return;
            }

            var step = lctx.step;
            ctx.profile.push(step);
            ret.on('error', function(err) {
                if (ctx == null) { return; }
                if (step.error.isZero()) {
                    var msgObj = { 'class': err.code, 'msg': err.message };
                    step.error = StatError.addError({}, msgObj, ctx.service_hash,
                                                        ctx.profile, TextTypes.HTTPC_URL, step.url);
                    if (ctx.error.isZero()) {
                        ctx.error = step.error;
                    }
                }

                endHttpc(ctx, step);
            });

            ret.on('socket', function(socket) {
                socket.on('timeout', function () {
                    if (ctx == null) { return; }

                    if (step.error.isZero()) {
                        var msgObj = { 'class': 'Timeout', 'msg': 'Timeout' };
                        step.error = StatError.addError({} /*Throwable*/, msgObj, ctx.service_hash, ctx.profile, 0, 0);
                        if (ctx.error.isZero()) {
                            ctx.error = step.error;
                        }
                    }

                    endHttpc(ctx, step);
                });
            });
        });

    function endHttpc(ctx, step) {
        step.elapsed = ctx.getElapsedTime() - step.start_time;
        ctx.active_httpc_hash = 0;
        ctx.httpc_url = null;
        ctx.httpc_host = null;
        ctx.httpc_count++;
        ctx.httpc_time += step.elapsed;

        MeterHttpC.add(step.elapsed, !step.error.isZero());
        StatHttpc.addHttpcTime(ctx.service_hash, step.url, step.host, step.port, step.elapsed, !step.error.isZero());
        ctx.profile.pop(step);
        ctx.stack.pop();
    }
};

exports.HttpObserver = HttpObserver;