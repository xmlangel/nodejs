/**
 * Copyright 2016 the WHATAP project authors. All rights reserved.
 * Use of this source code is governed by a license that
 * can be found in the LICENSE file.
 */


var HashUtil = require('./hashutil');

function LinkedEntry(key, value, next) {
    this.key = key;
    this.value = value;
    this.next = next;      /*LinkedEntry*/
    this.link_next = null; /*LinkedEntry*/
    this.link_prev = null; /*LinkedEntry*/
}
LinkedEntry.prototype.getKey = function () {
    return this.key;
};
LinkedEntry.prototype.getValue = function () {
    return this.value;
};
LinkedEntry.prototype.setValue = function (value) {
    var oldValue = this.value;
    this.value = value;
    return oldValue;
};
LinkedEntry.prototype.hashCode = function () {
    return HashUtil.hashFromString(this.key);
};
LinkedEntry.prototype.toString = function () {
    return this.key + "=" + this.value;
};

function Enumer(map, type) {
    this.map = map;
    this.entry = map.header.link_next;
    this.lastEnt = null;
    this.type = type || TYPE.ENTRIES;
}
Enumer.prototype.hasMoreElements = function () {
    return this.map.header != this.entry && this.entry != null;
};
Enumer.prototype.nextElement = function () {
    if(this.hasMoreElements()) {
        var e = this.lastEnt = this.entry;
        this.entry = e.link_next;
        switch (this.type) {
            case TYPE.KEYS :
                return e.key;
            case TYPE.VALUES :
                return e.value;
            default :
                return e;
        }
    }
    throw new Error("No more next");
};

const DEFAULT_CAPACITY = 101;
const DEFAULT_LOAD_FACTOR = 0.75;
const TYPE = {
    KEYS    : 0,
    VALUES  : 1,
    ENTRIES : 2
};
const MODE = {
    FORCE_FIRST : 0,
    FORCE_LAST  : 1,
    FIRST       : 2,
    LAST        : 3
};

function LinkedMap(initCapacity, loadFactor) {
    this.initCapacity = initCapacity || DEFAULT_CAPACITY;
    this.loadFactor = loadFactor || DEFAULT_LOAD_FACTOR;
    this.threshold = parseInt(this.initCapacity * this.loadFactor);

    this.table = new Array(this.initCapacity); /*LinkedEntry*/
    this.header = new LinkedEntry(null, null, null); /*LinkedEntry*/
    this.header.link_next = this.header.link_prev = this.header;
    this.count = 0;
    this.max = 0;
}
LinkedMap.prototype.size = function () {
    return this.count;
};
LinkedMap.prototype.keys = function () {
    return new Enumer(this, TYPE.KEYS);
};
LinkedMap.prototype.values = function () {
    return new Enumer(this, TYPE.VALUES);
};
LinkedMap.prototype.entries = function () {
    return new Enumer(this, TYPE.ENTRIES);
};
LinkedMap.prototype.containsValue = function (value) {
    if(value == null) {
        return false;
    }
    var tab = this.table;
    var i = tab.length;
    while(i-- > 0) {
        for(var e = tab[i]; e != null; e = e.next) {
            if(e.value === value) {
                return true;
            }
        }
    }
    return false;
};
LinkedMap.prototype.containsKey = function (key) {
    if(key == null) {
        return false;
    }
    var tab = this.table;
    var index = this.hash(key) % tab.length;

    for(var e = tab[index]; e != null; e = e.next) {
        if(e.key == key.toString()) {
            return true;
        }
    }
    return false;
};
LinkedMap.prototype.get = function (key) {
    if(key == null) {
        return null;
    }

    var tab = this.table;
    var index = this.hash(key) % tab.length;

    for(var e = tab[index]; e != null; e = e.next) {
        if(e.key.toString() === key.toString()) {
            return e.value;
        }
    }
    return null;
};
LinkedMap.prototype.getLastValue = function () {
    if(this.isEmpty()) {
        return null;
    }
    return this.header.link_prev.value;
};
LinkedMap.prototype.hash = function (key) {
    if(key == null) {
        return 0;
    }
    return HashUtil.hashFromString(key.toString()) & 0x7fffffff;
};
LinkedMap.prototype.rehash = function () {
    var oldCapacity = this.table.length;
    var oldMap = this.table;
    var newCapacity = oldCapacity * 2 + 1;
    var newMap = new Array(newCapacity);
    this.threshold = parseInt(newCapacity * this.loadFactor);
    this.table = newMap;

    for(var i=oldCapacity ; i-- > 0;) {
        for(var old = oldMap[i]; old!=null;) {
            var e = old;
            old = old.next;
            var key = e.key;
            var index = this.hash(key) % newCapacity;
            e.next = newMap[index];
            newMap[index] = e;
        }
    }

};
LinkedMap.prototype.isEmpty = function () {
    return this.size() == 0;
};
LinkedMap.prototype.setMax = function (max) {
    this.max = max;
    return this;
};
LinkedMap.prototype.isFull = function () {
    return this.max > 0 && this.max <= this.count;
};
LinkedMap.prototype.put = function (key, value) {
    return this._put(key, value, MODE.LAST);
};
LinkedMap.prototype.putLast = function (key, value) {
    return this._put(key, value, MODE.FORCE_LAST);
};
LinkedMap.prototype.putFirst = function (key, value) {
    return this._put(key, value, MODE.FORCE_FIRST);
};
LinkedMap.prototype._put = function (key, value, m, noover) {
    if(noover && this.max > 0 && this.size() > this.max) {
        return null;
    }
    var tab = this.table;
    var index = this.hash(key) % tab.length;
    for(var e = tab[index]; e != null; e = e.next) {
        if(e.key === key) {
            var old = e.value;
            e.value = value;
            switch(m) {
                case MODE.FORCE_FIRST:
                    if(this.header.link_next != e) {
                        this.unchain(e);
                        this.chain(this.header, this.header.link_next, e);
                    }
                    break;
                case MODE.FORCE_LAST:
                    if(this.header.link_prev != e) {
                        this.unchain(e);
                        this.chain(this.header.link_prev, this.header, e);
                    }
                    break;
            }
            return old;
        }
    }
    if( this.max > 0 ) {
        switch (m) {
            case MODE.FORCE_FIRST:
            case MODE.FIRST:
                while( this.count >= this.max ) {
                    var k = this.header.link_prev.key;
                    var v = this.remove(k);
                    this.overflowed(k, v);
                }
                break;
            case MODE.FORCE_LAST:
            case MODE.LAST:
                while( this.count >= this.max ) {
                    var k = this.header.link_next.key;
                    var v = this.remove(k);
                    this.overflowed(k, v);
                }
                break;
        }
    }
    if(this.count >= this.threshold) {
        this.rehash();
        tab = this.table;
        index = this.hash(key) % tab.length;
    }

    var e = new LinkedEntry(key ,value, tab[index]);
    tab[index] = e;

    switch (m) {
        case MODE.FORCE_FIRST:
        case MODE.FIRST:
            this.chain(this.header, this.header.link_next, e);
            break;
        case MODE.FORCE_LAST:
        case MODE.LAST:
            this.chain(this.header.link_prev, this.header, e);
            break;
    }
    this.count++;
    return null;
};
LinkedMap.prototype.overflowed = function (key, value) {

};
LinkedMap.prototype.create = function (key) {
    throw new Error('not implemented create()');
};
LinkedMap.prototype.intern = function (key) {
    return this._intern(key.toString(), MODE.LAST);
};
LinkedMap.prototype._intern = function (key, m) {
    var tab = this.table;
    var index = this.hash(key) % tab.length;

    for(var e = tab[index]; e != null; e = e.next) {
        if(e.key === key) {
            var old = e.value;
            switch(m) {
                case MODE.FORCE_FIRST:
                    if(this.header.link_next != e) {
                        this.unchain(e);
                        this.chain(this.header, this.header.link_next, e);
                    }
                    break;
                case MODE.FORCE_LAST:
                    if(this.header.link_prev != e) {
                        this.unchain(e);
                        this.chain(this.header.link_prev, this.header, e);
                    }
                    break;
            }
            return old;
        }
    }

    var value = this.create(key);
    if(value == null) {
        return null;
    }
    if(this.max > 0) {
        switch (m) {
            case MODE.FORCE_FIRST:
            case MODE.FIRST:
                while (this.count >= this.max) {
                    var k = this.header.link_prev.key;
                    var v = this.remove(k);
                    this.overflowed(k, v);
                }
                break;
            case MODE.FORCE_LAST:
            case MODE.LAST:
                while (this.count >= this.max) {
                    var k = this.header.link_next.key;
                    var v = this.remove(k);
                    this.overflowed(k, v);
                }
                break;
        }
    }
    if(this.count >= this.threshold) {
        this.rehash();
        tab = this.table;
        index = this.hash(key) % tab.length;
    }

    var e = new LinkedEntry(key, value, tab[index]);
    tab[index] = e;
    switch (m) {
        case MODE.FORCE_FIRST:
        case MODE.FIRST:
            this.chain(this.header, this.header.link_next, e);
            break;
        case MODE.FORCE_LAST:
        case MODE.LAST:
            this.chain(this.header.link_prev, this.header, e);
            break;
    }
    this.count++;
    return value;
};
LinkedMap.prototype.remove = function (key) {
    if(key == null) {
        return null;
    }
    var tab = this.table;
    var index = this.hash(key) % tab.length;
    for(var e = tab[index], prev = null; e != null; prev = e, e = e.next) {
        if(e.key === key) {
            if(prev != null) {
                prev.next = e.next;
            } else {
                tab[index] = e.next;
            }
            this.count--;
            var oldValue = e.value;
            e.value = null;
            this.unchain(e);
            return oldValue;
        }
    }
    return null;
};
LinkedMap.prototype.removeFirst = function () {
    if(this.isEmpty()) {
        return null;
    }
    return this.remove(this.header.link_next.key);
};
LinkedMap.prototype.removeLast = function () {
    if(this.isEmpty()) {
        return null;
    }
    return this.remove(this.header.link_prev.key);
};
LinkedMap.prototype.clear = function () {
    var tab = this.table;
    for(var index = tab.length; --index >=0;) {
        tab[index] = null;
    }
    this.header.link_next = this.header.link_prev = this.header;
    this.count = 0;
};
LinkedMap.prototype.chain = function (link_prev, link_next, e) {
    e.link_prev = link_prev;
    e.link_next = link_next;
    link_prev.link_next = e;
    link_next.link_prev = e;
};
LinkedMap.prototype.unchain = function (e) {
    e.link_prev.link_next = e.link_next;
    e.link_next.link_prev = e.link_prev;
    e.link_prev = null;
    e.link_next = null;
};
LinkedMap.prototype.putAll = function (other) {
    if(other == null || (other instanceof LinkedMap) == false) {
        return;
    }
    var it = other.entries();
    while(it.hasMoreElements()) {
        var e = it.nextElement();
        this.put(e.getKey(), e.getValue());
    }
};
LinkedMap.prototype.toString = function () {
    var str = '';
    var it = this.entries();
    str += '{';
    for(var i=0; it.hasMoreElements(); i++) {
        var e = it.nextElement();
        if(i > 0) {
            str += ", ";
        }
        str += e.getKey();
        str += "=";
        str += e.getValue();
    }
    str += "}";
    return str;
};

module.exports = LinkedMap;
module.exports.MODE = MODE;